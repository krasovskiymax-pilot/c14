# План реализации ChatList

Поэтапный порядок действий по реализации программы на основе спецификации PROJECT.md.

---

## Этап 1. Структура проекта и окружение

1.1. Создать структуру папок и файлов:
- `db.py` — модуль работы с БД
- `models.py` — логика моделей нейросетей
- `network.py` — отправка HTTP-запросов к API
- `main.py` — GUI и точка входа

1.2. Обновить `requirements.txt`: PyQt5, requests или httpx, python-dotenv.

1.3. Создать `.env.example` с перечнем переменных для API-ключей.

1.4. Добавить `.env` в `.gitignore` (если ещё не добавлен).

---

## Этап 2. База данных (модуль db.py)

2.1. Реализовать подключение к SQLite и создание БД при первом запуске.

2.2. Реализовать миграции или скрипт инициализации таблиц:
- `prompts`
- `models`
- `results`
- `settings`

2.3. Реализовать CRUD-операции для каждой таблицы.

2.4. Реализовать поиск и сортировку во всех таблицах (опционально на первом этапе).

---

## Этап 3. Логика моделей (модуль models.py)

3.1. Определить структуру данных модели (name, api_url, api_id, is_active).

3.2. Реализовать получение списка активных моделей из БД.

3.3. Реализовать добавление, редактирование и удаление моделей.

3.4. Реализовать загрузку API-ключей из `.env` по имени переменной (api_id).

---

## Этап 4. Сетевой слой (модуль network.py)

4.1. Реализовать функцию отправки промта к одной модели (базовый HTTP POST).

4.2. Добавить обработку ошибок (таймаут, ошибки HTTP, отсутствие ключа).

4.3. Реализовать асинхронную или конкурентную отправку запросов ко всем активным моделям.

4.4. Подготовить заготовки под разные типы API (OpenAI, DeepSeek, Groq) — при необходимости.

---

## Этап 5. Базовый GUI

5.1. Создать главное окно приложения.

5.2. Разделить интерфейс на зоны:
- область ввода/выбора промта
- область таблицы результатов
- кнопки управления (Отправить, Сохранить, Новый запрос)

5.3. Добавить меню (Файл, Настройки, Справка) и панель инструментов при необходимости.

---

## Этап 6. Ввод и выбор промта

6.1. Добавить текстовое поле (или многострочный редактор) для ввода нового промта.

6.2. Добавить выпадающий список или таблицу для выбора сохранённого промта из таблицы prompts.

6.3. При выборе сохранённого промта подставлять его текст в поле ввода.

6.4. Реализовать кнопку «Очистить» для сброса выбора и ввода.

---

## Этап 7. Отправка запроса и временная таблица

7.1. При нажатии «Отправить»:
- очищать текущую временную таблицу;
- получать список активных моделей;
- отправлять промт во все активные модели;
- собирать ответы в структуру в памяти (список словарей или объектов).

7.2. Показывать индикатор загрузки во время запросов.

7.3. Обрабатывать случаи: нет активных моделей, ошибка сети, частичные ответы.

---

## Этап 8. Интерфейс результатов

8.1. Создать таблицу (QTableWidget или QTableView с моделью) с колонками:
- Модель
- Ответ
- Выбрано (чекбокс)

8.2. Отображать данные из временной таблицы.

8.3. Реализовать прокрутку и автоподстройку ширины колонок при большом объёме текста.

---

## Этап 9. Сохранение результатов

9.1. При нажатии «Сохранить»:
- находить все строки с selected = True;
- записывать их в таблицу results (связь с prompt_id, model_id, текст ответа);
- при необходимости сохранять промт в prompts, если он новый;
- очищать временную таблицу и обновлять отображение.

9.2. Показать уведомление об успешном сохранении или об ошибке.

---

## Этап 10. Новый запрос и очистка

10.1. При вводе нового промта или нажатии «Новый запрос»:
- полностью очищать временную таблицу;
- очищать таблицу на экране;
- сбрасывать область ввода при необходимости.

10.2. Убедиться, что выбор «сохранённого промта» и «новый промт» работают согласованно.

---

## Этап 11. Настройки и управление моделями

11.1. Создать экран/диалог настройки моделей (добавление, редактирование, is_active).

11.2. Вынести доступ к настройкам из главного окна (меню или кнопка).

11.3. Сохранять настройки программы в таблицу settings.

---

## Этап 12. Интеграция и тестирование

12.1. Прогнать полный сценарий: ввод промта → отправка → просмотр → сохранение.

12.2. Проверить работу с пустой БД и с предзаполненными данными.

12.3. Исправить выявленные ошибки и доработать UX.

---

## Этап 13. Дополнительные функции (опционально)

13.1. Реализовать поиск и сортировку во всех таблицах.

13.2. Реализовать экспорт выбранных результатов в Markdown и JSON.

13.3. Добавить поддержку разных типов API (OpenAI, DeepSeek, Groq и т.д.).

13.4. Реализовать логирование запросов.

13.5. Обновить сборку PyInstaller под новую структуру проекта.
